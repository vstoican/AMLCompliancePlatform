# PostgreSQL/TimescaleDB Performance Tuning for High-Throughput Transaction Processing
# Optimized for write-heavy workloads

# =============================================================================
# MEMORY SETTINGS
# =============================================================================

# Shared memory for caching (25% of available RAM, adjust based on container limits)
shared_buffers = 512MB

# Memory per operation (sorts, joins, etc.)
work_mem = 64MB

# Memory for maintenance operations (VACUUM, CREATE INDEX)
maintenance_work_mem = 256MB

# Memory for WAL buffers
wal_buffers = 64MB

# Effective cache size (estimate of OS cache, ~75% of RAM)
effective_cache_size = 1536MB

# =============================================================================
# WAL & CHECKPOINT SETTINGS (Critical for Write Performance)
# =============================================================================

# Async commit - 2-3x faster writes, tiny durability window (~10ms data loss risk on crash)
synchronous_commit = off

# Delay between WAL writes - batch more writes together
wal_writer_delay = 200ms

# WAL level (replica allows replication if needed later)
wal_level = replica

# Max WAL size before checkpoint
max_wal_size = 2GB
min_wal_size = 512MB

# Spread checkpoint writes over this fraction of checkpoint interval
checkpoint_completion_target = 0.9

# Checkpoint timeout
checkpoint_timeout = 15min

# =============================================================================
# CONNECTION SETTINGS
# =============================================================================

# Listen on all interfaces (required for Docker networking)
listen_addresses = '*'

# Max connections (each consumer uses pool of ~20)
max_connections = 200

# =============================================================================
# QUERY PLANNER
# =============================================================================

# Cost estimates for planner
random_page_cost = 1.1          # SSD storage
effective_io_concurrency = 200  # SSD can handle parallel IO
seq_page_cost = 1.0

# Parallelism
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
max_worker_processes = 16

# =============================================================================
# BACKGROUND WRITER
# =============================================================================

# Write dirty buffers more aggressively
bgwriter_delay = 50ms
bgwriter_lru_maxpages = 400
bgwriter_lru_multiplier = 4.0

# =============================================================================
# AUTOVACUUM (Tuned for high-write tables)
# =============================================================================

autovacuum = on
autovacuum_max_workers = 4
autovacuum_naptime = 30s
autovacuum_vacuum_threshold = 1000
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_threshold = 500
autovacuum_analyze_scale_factor = 0.05

# =============================================================================
# LOGGING (Minimal for performance)
# =============================================================================

log_min_duration_statement = 1000  # Log queries > 1 second
log_checkpoints = on
log_lock_waits = on

# =============================================================================
# TIMESCALEDB SPECIFIC
# =============================================================================

# Preload TimescaleDB
shared_preload_libraries = 'timescaledb'

# TimescaleDB telemetry off
timescaledb.telemetry_level = off
